// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4415.SteamShipBot1Final.subsystems;

import org.usfirst.frc4415.SteamShipBot1Final.RobotMap;
import org.usfirst.frc4415.SteamShipBot1Final.commands.*;
import org.usfirst.frc4415.SteamShipBot1Final.Robot;

import com.ctre.CANTalon;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Turret extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	boolean resetTurret = false;
	
	private final double LEFT = -1;
	private final double RIGHT = 1;
	private final double OFF = 0;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon turretMotor = RobotMap.turretturretMotor;
    private final DigitalInput leftLimit = RobotMap.turretLeftLimit;
    private final DigitalInput middleLimit = RobotMap.turretMiddleLimit;
    private final DigitalInput rightLimit = RobotMap.turretRightLimit;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new TurretDefault());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void turretOff() {
		turretMotor.set(OFF);
	}

	public boolean getLeftLimit() {
		return leftLimit.get();
	}

	public boolean getMiddleLimit() {
		return middleLimit.get();
	}

	public boolean getRightLimit() {
		return rightLimit.get();
	}

	public void turn(double power) {
		if ((power > (RIGHT / 8) && rightLimit.get() == true) || 
				(power < (LEFT / 8) && leftLimit.get() == true)) {
			turretMotor.set(power);

		} else {
			turretMotor.set(OFF);
			
		}
	}
	
	public void reset() {
		if(middleLimit.get() == false){
			while(middleLimit.get() == false){
				turn(RIGHT);
			}
		}
		
		while(middleLimit.get() == true && leftLimit.get() == true) {
			turn(LEFT);
		}

		if (middleLimit.get() == false) {
			long startTime = System.currentTimeMillis();
			while(System.currentTimeMillis() - startTime < 175){
				turn(LEFT);
				sleep(10);
			}
		}	
		
		if (leftLimit.get() == false) {
			while(middleLimit.get() == true) {
				turn(RIGHT);
			}
			long startTime = System.currentTimeMillis();
			while(System.currentTimeMillis() - startTime < 95){
				turn(RIGHT);
				sleep(10);
			}

			turretMotor.set(OFF);

		}
	}
	
	public void autoAim(){
		
		// moving CCW (topview) (left) = error increases (positive direction) 
		// if error is positive, we want to move CW
		
		long timeoutStart = System.currentTimeMillis();
		double pIDTimeout = Robot.tableReader.get("pidtimeout", 10000);
		
		double pGain = Robot.tableReader.get("pgainturret", 0.03);
		double iGain = Robot.tableReader.get("igainturret", 0.0);
		double pIDClipping = Robot.tableReader.get("pidclippingturret", 0.8);
		double threshold = Robot.tableReader.get("thresholdturret", 20);
		double deadband = Robot.tableReader.get("deadbandturret", 0.25);

		double gyroStart = Robot.navX.getAngle();
		double gyroCurrent = gyroStart;
		
		boolean done = false;
		int loopCounter = 0;
		double thresholdCounter = Robot.tableReader.get("thresholdcounter", 20);
		boolean accumulatorEnable = false;
		double accumulator = 0;
		boolean movingClockwise = false;
		
		// if error > 0, need to move clockwise to get to target
		double error = 0; 		//Robot.targetReader.getX();
		if(error > 0){
			movingClockwise = true;
		}
		
		while(!done){
			error = 0; // Robot.targetReader.getX();
			
			// ASSUMING pTerm is positive when moving clockwise
			double deadbandSign = 0;
			if(error > 0) deadbandSign = 1;
			else deadbandSign = -1;
			double pTerm = pGain * (error) + 
					(deadbandSign * deadband);
			
			double iTerm = 0;
			
			// this checks if current position has crossed the setpoint yet
			if((movingClockwise && error <= 0) 
					|| (!movingClockwise && error >= 0)){
				accumulatorEnable = true;		// once set true, can never go false		
			}
			if(accumulatorEnable){
				accumulator += error;
				// ASSUMING iTerm is positive when moving clockwise
				iTerm = iGain * accumulator;
			}
			
			double rotateValue = Math.max(pIDClipping * -1,  
					Math.min(pIDClipping, pTerm+iTerm));
			turn(rotateValue);
			
			if(Math.abs(error) < threshold) {
				loopCounter++;
			} else {
				loopCounter = 0;
			}
			
			if(loopCounter > thresholdCounter || 
					(System.currentTimeMillis() - timeoutStart) > pIDTimeout) {
				done = true;
			}
			
			sleep(10);
			
			System.out.printf("  Error: %5.3f", error);
			System.out.print("  Dir: ");
			if(error>0) System.out.print("CW ");
			else System.out.print("CCW");
			System.out.printf("  pTerm: %3.3f  iTerm: %3.3f", pTerm, iTerm);
			System.out.println("  Done: " + done);
		}
	}
	
	public void sleep(int millis){
		try {
			Thread.sleep(millis);
		} catch (InterruptedException e){
			e.printStackTrace();
		}
	}

}

